package me.maxallgaier.playermanagement.util;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;

import java.time.Duration;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

// Generated by Claude.
class DurationParserTest {
    DurationParser parser;
    DurationParser.KeywordConfig config;

    @BeforeEach
    void setUp() {
        config = new DurationParser.KeywordConfig(
            List.of("permanent", "perm"),
            List.of("days", "day", "d"),
            List.of("hours", "hour", "hrs", "hr", "h"),
            List.of("minutes", "minute", "mins", "min", "m"),
            List.of("seconds", "second", "secs", "sec", "s")
        );
        parser = new DurationParser(config);
    }

    @Test
    @DisplayName("Parse single day value")
    void testSingleDay() {
        Duration result = parser.fromString("5days");
        assertEquals(Duration.ofDays(5), result);
    }

    @Test
    @DisplayName("Parse single hour value")
    void testSingleHour() {
        Duration result = parser.fromString("3hours");
        assertEquals(Duration.ofHours(3), result);
    }

    @Test
    @DisplayName("Parse single minute value")
    void testSingleMinute() {
        Duration result = parser.fromString("45minutes");
        assertEquals(Duration.ofMinutes(45), result);
    }

    @Test
    @DisplayName("Parse single second value")
    void testSingleSecond() {
        Duration result = parser.fromString("30seconds");
        assertEquals(Duration.ofSeconds(30), result);
    }

    @Test
    @DisplayName("Parse multiple time units")
    void testMultipleUnits() {
        Duration result = parser.fromString("2days3hours30minutes45seconds");
        Duration expected = Duration.ofDays(2)
            .plusHours(3)
            .plusMinutes(30)
            .plusSeconds(45);
        assertEquals(expected, result);
    }

    @Test
    @DisplayName("Parse with whitespace trimming")
    void testWithWhitespace() {
        Duration result = parser.fromString("  5days  ");
        assertEquals(Duration.ofDays(5), result);
    }

    @Test
    @DisplayName("Parse with short unit names")
    void testShortUnitNames() {
        Duration result = parser.fromString("1d2h3m4s");
        Duration expected = Duration.ofDays(1)
            .plusHours(2)
            .plusMinutes(3)
            .plusSeconds(4);
        assertEquals(expected, result);
    }

    @Test
    @DisplayName("Parse with mixed case units")
    void testMixedCaseUnits() {
        Duration result = parser.fromString("5DAYS3Hours");
        Duration expected = Duration.ofDays(5).plusHours(3);
        assertEquals(expected, result);
    }

    @Test
    @DisplayName("Parse multiple values of same unit")
    void testMultipleSameUnit() {
        Duration result = parser.fromString("2days3days5days");
        assertEquals(Duration.ofDays(10), result);
    }

    @Test
    @DisplayName("Parse with no unit separator")
    void testNoUnitSeparator() {
        Duration result = parser.fromString("1h30m");
        Duration expected = Duration.ofHours(1).plusMinutes(30);
        assertEquals(expected, result);
    }

    @ParameterizedTest
    @ValueSource(strings = {"", "   ", "\t", "\n"})
    @DisplayName("Throw exception for empty or whitespace-only strings")
    void testEmptyString(String input) {
        RuntimeException exception = assertThrows(RuntimeException.class,
            () -> parser.fromString(input));
        assertEquals("empty string provided", exception.getMessage());
    }

    @ParameterizedTest
    @ValueSource(strings = {"days", "hello5days", "abc123"})
    @DisplayName("Throw exception when string doesn't start with number")
    void testNotStartingWithNumber(String input) {
        RuntimeException exception = assertThrows(RuntimeException.class,
            () -> parser.fromString(input));
        assertEquals("string does not start with a number", exception.getMessage());
    }

    @Test
    @DisplayName("Throw exception for unknown unit")
    void testUnknownUnit() {
        RuntimeException exception = assertThrows(RuntimeException.class,
            () -> parser.fromString("5weeks"));
        assertTrue(exception.getMessage().contains("unknown unit"));
    }

    @Test
    @DisplayName("Parse zero values")
    void testZeroValues() {
        Duration result = parser.fromString("0days");
        assertEquals(Duration.ZERO, result);
    }

    @Test
    @DisplayName("Parse large numbers")
    void testLargeNumbers() {
        Duration result = parser.fromString("999days");
        assertEquals(Duration.ofDays(999), result);
    }

    @ParameterizedTest
    @CsvSource({
        "1day, 1",
        "2hr, 2",
        "3min, 3",
        "4sec, 4"
    })
    @DisplayName("Parse alternative unit names")
    void testAlternativeUnitNames(String input, int expectedValue) {
        Duration result = parser.fromString(expectedValue + input.substring(1));
        assertNotNull(result);
    }

    @Test
    @DisplayName("KeywordConfig getAllNonPermanentKeywordsSortedByLength returns sorted list")
    void testGetAllNonPermanentKeywordsSorted() {
        List<String> sorted = config.getAllNonPermanentKeywordsSortedByLength();

        // Check that longer strings come first
        for (int i = 0; i < sorted.size() - 1; i++) {
            assertTrue(sorted.get(i).length() >= sorted.get(i + 1).length(),
                "Keywords should be sorted by length descending");
        }

        // Check that all non-permanent keywords are included
        assertTrue(sorted.contains("days"));
        assertTrue(sorted.contains("hours"));
        assertTrue(sorted.contains("minutes"));
        assertTrue(sorted.contains("seconds"));
    }

    @Test
    @DisplayName("KeywordConfig getAllPermanentKeywordsSortedByLength returns sorted list")
    void testGetAllPermanentKeywordsSorted() {
        List<String> sorted = config.getAllPermanentKeywordsSortedByLength();

        // Check that longer strings come first
        for (int i = 0; i < sorted.size() - 1; i++) {
            assertTrue(sorted.get(i).length() >= sorted.get(i + 1).length(),
                "Keywords should be sorted by length descending");
        }

        // Check that all permanent keywords are included
        assertTrue(sorted.contains("permanent"));
        assertTrue(sorted.contains("perm"));
        assertEquals("permanent", sorted.get(0));
    }

    @Test
    @DisplayName("Parse complex real-world example")
    void testComplexExample() {
        Duration result = parser.fromString("1d12h30m45s");
        Duration expected = Duration.ofDays(1)
            .plusHours(12)
            .plusMinutes(30)
            .plusSeconds(45);
        assertEquals(expected, result);
    }

    @Test
    @DisplayName("Handle unit with no space after number")
    void testNoSpaceAfterNumber() {
        Duration result = parser.fromString("50days60hours1minutes");
        Duration expected = Duration.ofDays(50)
            .plusHours(60)
            .plusMinutes(1);
        assertEquals(expected, result);
    }
}
